#!/usr/bin/env python
# -*- python -*-
#
#  @file template.py
#  @brief doil servant class template
#  @date $Date$
#  @author Noriaki Ando <n-ando@aist.go.jp>
# 
#  Copyright (C) 2008
#      Task-intelligence Research Group,
#      Intelligent Systems Research Institute,
#      National Institute of
#          Advanced Industrial Science and Technology (AIST), Japan
#      All rights reserved.
# 
#  $Id$
# 


# doil type conversion header
typeconv_h = """\
// -*- C++ -*-
/*!
 * @file [servant_h]
 * @brief [servant_name] CORBA servant for doil
 * @date $Date$
 * @author This file was automatically generated by omniidl/doil backend
 *
 * $Id$
 */

#ifndef [servant_include_guard]
#define [servant_include_guard]

#include <doil/corba/BasicTypes.h>

[for t in types]
inline void operator<<([t.type_l]& lhs, [t.type_r]& rhs)
{
  [for m in t.member]
  lhs.[m] << rhs.[m];
  [endfor]
}
[endfor]


#endif // [servant_include_guard]
"""


#
# doil servant header file template
#
# Given keys.
# - servant_name   : doil servant class name
# - iface_name : interface class name to be delegated by this servant
# - include_guard  : include guard definition name
# - fq_POA_name    : fully qualified POA name
# - operations     : operation definitions
#
servant_h = """\
// -*- C++ -*-
/*!
 * @file [servant_h] 
 * @brief [servant_name] CORBA servant for doil
 * @date $Date$
 * @author This file was automatically generated by omniidl/doil backend
 *
 * $Id$
 */
#ifndef [servant_include_guard] 
#define [servant_include_guard] 

#include <coil/Properties.h>
#include <doil/corba/CORBAManager.h>
[for inc in include_h]
#include <[inc]>
[endfor]

namespace doil
{
  class ImplBase;
};

// interface class forward declaration
[for ns in iface_ns]
namespace [ns] 
{
[endfor]
  class [iface_name];
[for ns in iface_ns]
}; // namespace [ns]

[endfor]


[for ns in servant_ns]
namespace [ns] 
{
[endfor]

  class [servant_name] 
   : public virtual [corba_poa_name],
     public virtual doil::CORBA::CORBAServantBase
  {
  public:
    [servant_name](doil::ImplBase* impl);
    virtual ~[servant_name]();

[for op in operations]
    virtual [op.return.corba.ret_type] [op.name]
([for a in op.args]
[if-index a is last][a.corba.arg_type] [a.corba.arg_name]
[else][a.corba.arg_type] [a.corba.arg_name], [endif]
[endfor]);
[endfor]

  private:
    [iface_name]* m_impl;
  };

[for ns in servant_ns]
}; // namespace [ns] 
[endfor]

// Object conversion functions
// local object -> corba object
bool operator<<([corba_iface]_ptr& lhs, [iface_name]* rhs)
{
  CORBA::Object_ptr obj;
  obj = doil::CORBA::CORBAManager::instance().toReference(rhs);
  lhs = [corba_iface]::_narrow(obj);
  if (CORBA::is_nil(lhs)) return false;
  return true;
}

// corba object -> local object
bool operator<<([iface_name]* lhs, [corba_iface]_ptr& rhs)
{
  doil::LocalBase* lobj;
  lobj = doil::CORBA::CORBAManager::instance().toLocal(rhs);
  if (lobj == NULL) return false;
  lhs = dynamic_cast<[iface_name]*>(lobj);
  if (lobj == NULL) return false;
  return true;
}

extern "C"
{
  void [servant_name]CORBAInit(coil::Properties& prop);
};

#endif // [servant_include_guard]
"""

#
# doil servant code file template
#
# Given keys.
# - servant_name   : doil servant class name
# - iface_name : interface class name to be delegated by this servant
# - include_guard  : include guard definition name
# - fq_POA_name    : fully qualified POA name
# - operations     : operation definitions
#
servant_cpp = """\
// -*- C++ -*-
/*!
 * @file [servant_cpp] 
 * @brief [iface_name] CORBA servant for doil
 * @date $Date$
 * @author This file was automatically generated by omniidl/doil backend
 *
 * $Id$
 */

#include <doil/ImplBase.h>
#include <doil/corba/CORBAManager.h>
#include <[iface_h_path]>
#include <[servant_h_path]>

[for ns in servant_ns]
namespace [ns] 
{
[endfor]
  /*!
   * @brief ctor
   */ 
  [servant_name]::[servant_name](doil::ImplBase* impl)
   : m_impl(NULL)
  {
    m_impl = dynamic_cast<[iface_name]*>(impl);
    if (m_impl == NULL) throw std::bad_alloc();
    m_impl->incRef();
  }

  /*!
   * @brief dtor
   */ 
  [servant_name]::~[servant_name]()
  {
    m_impl->decRef();
  }

  [for op in operations]

  /*!
   * @brief [op.name] 
   */ 
  [op.return.corba.ret_type] [servant_name]::[op.name]
([for a in op.args]
[if-index a is last][a.corba.arg_type] [a.corba.arg_name]
[else][a.corba.arg_type] [a.corba.var_name], [endif]
[endfor])
  {
[for a in op.args]
    [a.local.decl_type] _[a.local.arg_name];
[endfor]

[for a in op.args][if a.corba.direction is out][else]
    [a.local.var_name] << [a.corba.arg_name];
[endif][endfor]

[if op.return.corba.tk is tk_void][else]
    [op.return.local.decl_type] local_ret;
    [op.return.corba.ret_type] corba_ret;
    local_ret = [endif]
m_impl->[op.name]
([for a in op.args][if-index a is last][a.local.var_name][else][a.local.var_name], [endif][endfor]);
[if op.return.corba.tk is tk_void][else]
    corba_ret << local_ret;
[endif]

[for a in op.args][if a.corba.direction is in][else]
    [a.corba.arg_name] << [a.local.var_name];
[endif][endfor]
[if op.return.corba.tk is tk_void][else]
    return corba_ret;
[endif]
  }
[endfor]

[for ns in servant_ns]
}; // namespace [ns] 
[endfor]

extern "C"
{
  void [servant_name]CORBAInit(coil::Properties& prop)
  {
    doil::CORBA::CORBAManager& mgr(doil::CORBA::CORBAManager::instance());
    mgr.registerFactory("[servant_name]",
                        doil::New<[servant_name]>,
                        doil::Delete<[servant_name]>);
  }
};
"""





adapter_h = """
// -*- C++ -*-
/*!
 * @file [adapter_h] 
 * @brief [adapter_name] CORBA adapter for doil
 * @date $Date$
 * @author This file was automatically generated by omniidl/doil backend
 *
 * $Id$
 */
#ifndef [adapter_include_guard] 
#define [adapter_include_guard] 

#include <coil/Properties.h>
#include <doil/corba/CORBAManager.h>
#include <doil/ImplBase.h>
#include <[iface_h]>
#include <[adapter_h_path]>
[for inc in include_h]
#include <[inc]>
[endfor]


[for ns in adapter_ns]
namespace [ns] 
{
[endfor]

  class [adapter_name] 
   : public virtual doil::LocalBase,
     public virtual [iface_name]

  {
  public:
    [adapter_name](::CORBA::Object_ptr obj);
    virtual ~[adapter_name]();

[for op in operations]
    virtual [op.return.local.ret_type] [op.name]
([for a in op.args]
[if-index a is last][a.local.arg_type] [a.local.arg_name]
[else][a.local.arg_type] [a.local.arg_name], [endif]
[endfor]);
[endfor]

  private:
    [corba_iface]_ptr m_obj;
  };

[for ns in adapter_ns]
}; // namespace [ns] 
[endfor]

#ifndef [servant_include_guard] 

// Object conversion functions
// local object -> corba object
bool operator<<([corba_iface]_ptr& lhs, [iface_name]* rhs)
{
  CORBA::Object_ptr obj;
  obj = doil::CORBA::CORBAManager::instance().toReference(rhs);
  lhs = [corba_iface]::_narrow(obj);
  if (CORBA::is_nil(lhs)) return false;
  return true;
}

// corba object -> local object
bool operator<<([iface_name]* lhs, [corba_iface]_ptr& rhs)
{
  doil::LocalBase* lobj;
  lobj = doil::CORBA::CORBAManager::instance().toLocal(rhs);
  if (lobj == NULL) return false;
  lhs = dynamic_cast<[iface_name]*>(lobj);
  if (lobj == NULL) return false;
  return true;
}

#endif // [servant_include_guard]


extern "C"
{
  void [adapter_name]CORBAInit(coil::Properties& prop);
};

#endif // [adapter_include_guard]

"""


adapter_cpp = """\
// -*- C++ -*-
/*!
 * @file [adapter_cpp] 
 * @brief [iface_name] CORBA adapter for doil
 * @date $Date$
 * @author This file was automatically generated by omniidl/doil backend
 *
 * $Id$
 */

#include <doil/ImplBase.h>
#include <doil/corba/CORBAManager.h>
#include <[iface_h_path]>
#include <[adapter_h_path]>

[for ns in adapter_ns]
namespace [ns] 
{
[endfor]
  /*!
   * @brief ctor
   */ 
  [adapter_name]::[adapter_name](::CORBA::Object_ptr obj)
   : m_obj(::CORBA::Object::_nil())
  {
    m_obj = [corba_iface]::_narrow(obj);
    if ([corba_iface]::is_nil(m_obj)) throw std::bad_alloc();
    m_obj = [corba_iface]::duplicate(m_obj);
  }

  /*!
   * @brief dtor
   */ 
  [adapter_name]::~[adapter_name]()
  {
    ::CORBA::release(m_obj);
  }

  [for op in operations]

  /*!
   * @brief [op.name] 
   */ 
  [op.return.local.ret_type] [adapter_name]::[op.name]
([for a in op.args]
[if-index a is last][a.local.arg_type] [a.local.arg_name]
[else][a.local.arg_type] [a.local.arg_name], [endif]
[endfor])
  {
[for a in op.args]
    [a.corba.decl_type] _[a.corba.arg_name];
[endfor]

[for a in op.args][if a.local.direction is out][else]
    [a.corba.var_name] << [a.local.arg_name];
[endif][endfor]

[if op.return.local.tk is tk_void][else]
    [op.return.corba.ret_type] _ret;
    [op.return.local.ret_type] ret;
    _ret = [endif]
m_obj->[op.name]
([for a in op.args][if-index a is last][a.corba.var_name][else][a.corba.var_name], [endif][endfor]);

[for a in op.args][if a.local.direction is in][else]
    [a.local.arg_name] << [a.corba.var_name];
[endif][endfor]
[if op.return.local.tk is tk_void][else]
    ret << _ret;
    return ret;
[endif]
  }
[endfor]

[for ns in adapter_ns]
}; // namespace [ns] 
[endfor]

extern "C"
{
  void [adapter_name]CORBAInit(coil::Properties& prop)
  {
    doil::CORBA::CORBAManager& mgr(doil::CORBA::CORBAManager::instance());
    mgr.registerFactory("[adapter_name]",
                        doil::New<[adapter_name]>,
                        doil::Delete<[adapter_name]>);
  }
};
"""
