#!/usr/bin/env python
# -*- python -*-
#
#  @file rtc-template
#  @brief rtc-template RTComponent source code generator tool
#  @date $Date: 2005-09-08 09:24:18 $
#  @author Noriaki Ando <n-ando@aist.go.jp>
# 
#  Copyright (C) 2004-2005
#      Task-intelligence Research Group,
#      Intelligent Systems Research Institute,
#      National Institute of
#          Advanced Industrial Science and Technology (AIST), Japan
#      All rights reserved.
# 
#  $Id: rtc-template,v 1.4 2005-09-08 09:24:18 n-ando Exp $
#

#
#  $Log: not supported by cvs2svn $
#  Revision 1.3  2005/09/06 14:37:40  n-ando
#  rtc-template's command options and data structure for ezt (Easy Template)
#  are changed for RTComponent's service features.
#  Now rtc-template can generate services' skeletons, stubs and
#  implementation files.
#  The implementation code generation uses omniidl's IDL parser.
#
#  Revision 1.2  2005/08/26 11:32:26  n-ando
#  "rtc-template" was completely rewritten to use ezt (Easy Template) module.
#  "ezt" module is originally included in "Subversion".
#
#  Now template code generator modules, which are named xxx_gen.py, are
#  automatically imported from rtc-template, and command options and help
#  menu are automatically generated.
#
#  New template code generator has to inherit base_gen class in
#  "base_gen.py" module to utilize this framework.
#
#  Revision 1.1.1.1  2005/05/12 09:06:18  n-ando
#  Public release.
#
#

import getopt, sys
import re
import os

libdir_path = os.popen("rtm-config --libdir", "r").read().split("\n")
pyhelper_path = libdir_path[0] + "/py_helper"
print pyhelper_path
sys.path.append(pyhelper_path)


# Option format
opt_args_fmt = ["help",
				"module-name=",
				"module-desc=",
				"module-version=",
				"module-author=",
				"module-category=",
				"module-comp-type=",
				"module-act-type=",
				"module-max-inst=",
				"module-lang=",
				"inport=",
				"outport=",
				"svc-idl=",
				"svc-idl-include=",
				"svc-name=",
				"svc-impl-suffix=",
				"svc-skel-suffix=",
				"svc-stub-suffix=",
				"backend="]


def usage_short():
	"""
	Help message
	"""
	print """
Usage: rtc-template [OPTIONS]

Options:

    [-h]                                  Print short help.
    [--help]                              Print details help.
    [--backend[=backend] or -b]           Specify template code generator.
    [--output[=output_file] or -o]        Output base file name.
    [--module-name[=name]]                Your module name.
    [--module-desc[=description]]         Module description.
    [--module-version[=version]]          Module version.
    [--module-author[=author]]            Module author.
    [--module-category[=category]]        Module category.
    [--module-comp-type[=component_type]] Component type.
    [--module-act-type[=activity_type]]   Component's activity type.
    [--module-max-inst[=max_instance]]    Number of maximum instance.
    [--module-lang[=language]]            Language.
    [--inport[=PortName:Type]]            InPort's name and tyoe.
    [--outport[=PortName:Type]]           OutPort's name and type
    [--svc-idl[=IDL_file]]                IDL file name
    [--svc-name[=if_name:name:type]]      Mapping: IF name, name and type
    [--svc-impl-suffix[=suffix]]          Suffix of implementation class
    [--svc-skel-suffix[=suffix]]          Suffix of server skeleton files
    [--svc-stub-suffix[=suffix]]          Suffix of client stub files
"""
def usage_long():
	"""
	Help message
	"""
	print """
    --output[=output_file]:
        Specify base name of output file. If 'XXX' is specified,
        C++ source codes XXX.cpp, XXX.h, XXXComp.cpp Makefile.XXX is generated.

    --module-name[=name]:
        Your component's base name. This string is used as module's
        name and component's base name. A generated new component
        class name is also names as this RTC_MODULE_NAME.
        Only alphabetical and numerical characters are acceptable.

    --module-desc[=description]:
        Short description. If space characters are included, string should be
        quoted.

    --module-version[=version]:
        Your module version. ex. 1.0.0

    --module-author[=author]:
        Author's name of this component.

    --module-category[=category]:
        This component module's category. ex. Manipulator MobileRobot, etc...

    --module-comp-type[=component_type]:
        Specify component type.
	    'STATIC', 'UNIQUE', 'COMMUTATIVE' are acceptable.

    --module-act-type[=activity_type]:
        Specify component activity's type.
        'PERIODIC', 'SPORADIC', 'EVENT_DRIVEN' ace acceptable.

    --module-max-inst[=max_instance]:
        Specify maximum number of component instance.

    --inport=[PortName:Type]:
        Specify InPort's name and type. 'PortName' is used as this InPort's
        name. This string is also used as variable name in soruce code.
        'Type' is InPort's variable type. The acceptable types are,
        Timed[ Short | Long | UShort | ULong | Float | Double | Char | Boolean
        | Octet | String ] and its sequence types.

    --outport=[PortName:Type]:
        Specify OutPort's name and type. 'PortName' is used as this OutPort's
        name. This string is also used as variable name in soruce code.
        'Type' is OutPort's variable type. The acceptable types are,
        Timed[ Short | Long | UShort | ULong | Float | Double | Char | Boolean
        | Octet | String ] and its sequence types.
		
    --svc-idl=[IDL filename]:
        Specify IDL file of RTCService.
        RTComponent service interface definition should include RTCService.idl
        and inherit RTCService interface.
        For simplicity, please define one interface in one IDL file, although
        this IDL file can include two or more interface definition,
		
    --svc-name=[Interface name:Service name: Service type]:
        Specify RTComponent's service name and service type with the
        corresponding interface name.

    --svc-impl-suffix=[Suffix]:
        Specify the suffix for implementation class name. This suffix is also
        used for implementation class header file and code file.
	
    --svc-skel-suffix=[Suffix]:
        Specify the suffix for server skeleton files.
	
    --svc-stub-suffix=[Suffix]:
        Specify the suffix for client stub files.
	

Example:
    rtc-template -bcxx \\
    --module-name=Sample --module-desc='Sample component' \\
    --module-version=0.1 --module-author=DrSample --module-category=Generic \\
    --module-comp-type=COMMUTATIVE --module-act-type=SPORADIC \\
    --module-max-inst=10  \\
    --inport=Ref:TimedFloat --inport=Sens:TimedFloat \\
    --outport=Ctrl:TimedDouble --outport=Monitor:TimedShort \\
    --svc-idl=MyService.idl --svc-name=MyService:MySVC:MySVC

"""
	return

def usage():
	usage_short()
	usage_long()
	return

class ModuleProfile:
	"""
	ModuleProfile class

	This class create RTM module profile for ezt.
	"""
	
	def __init__(self, name="", desc="", version="", author="",
				 category="", comp_type="", act_type="",
				 max_inst="", lang=""):

		self.name = name
		self.desc = desc
		self.version = version
		self.author = author
		self.category = category
		self.comp_type = comp_type
		self.act_type = act_type
		self.max_inst = max_inst
		self.lang = lang
		return
	

	def setValue(self, member, value):
		member = member.replace("-", "_")
		if hasattr(self, member):
			setattr(self, member, value)
		else:
			print "Invalid option: --module-" + member + " " + value
		return
	
	def setName(self, name):
		self.name = name
		return
	
	def setDesc(self, desc):
		self.desc = desc
		return
	
	def setVersion(self, version):
		self.version = version
		return
	
	def setAuthor(self, author):
		self.author = author
		return
	
	def setCategory(self, vategory):
		self.category = category
		return

	def setCompType(self, comp_type):
		self.comp_type = comp_type
		return

	def setActType(self, act):
		self.act_type = act_type
		return

	def setMaxInst(self, max_inst):
		self.max_inst = max_inst
		return

	def printProfile(self):
		print "----- Module Profile -----"
		print "Name           ", self.name
		print "Description    ", self.desc
		print "Version        ", self.version
		print "Author         ", self.author
		print "Category       ", self.category
		print "Component Type ", self.comp_type
		print "Activity Type  ", self.act_type
		print "Max Instancese ", self.max_inst
		print "Language       ", self.lang
		return
		


class PortProfile:
	"""
	PortProfile class

	This class create PortProfile for ezt
	"""
	def __init__(self, name="", type="", num=""):
		self.name = name
		self.type = type
		self.num  = num
		return
	
	def setValue(self, member, value):
		member = member.replace("-", "_")
		if hasattr(self, member):
			setattr(self, member, value)
		return


class ServiceProfile:
	"""
	ServiceProfile class

	Create ServiceProfile object for ezt
	members
	  ifname:      Service interface name
	  name:        Service name
	  type:        Service type
	  impl_suffix: Suffix of implementation class
	  skel_suffix: Suffix of skeleton class file
	  stub_suffix: Suffix of stub class file
	  class_impl : Class name of implementation class
	  profile:     Service profile object name
	"""
	def __init__(self, ifname = "", name= "", type= "",
				 impl_suffix = "", skel_suffix = "Skel", stub_suffix = "Stub"):
		self.ifname = ifname
		self.name = name
		self.type = type
		self.impl_suffix = impl_suffix
		self.skel_suffix = skel_suffix
		self.stub_suffix = stub_suffix
		self.class_impl = self.ifname + self.impl_suffix
		self.profile = self.ifname + "Profile"
		return
	
	def setValue(self, member, value):
		member = member.replace("-", "_")
		if hasattr(self, member):
			setattr(self, member, value)
		return
		
class ServiceIDL:
	"""
	ServiceIDL class

	Create ServiceIDL object for ezt
	members
	  idl_fname: IDL filename
	  idl_basename: Basename of IDL file
	  impl_basename: Basename of implementation class file
	  impl_h: Implementation header file name
	  impl_cpp: Implementation code file name
	  impl_suffix: Suffix of implementation class
	  skel_suffix: Suffix of skeleton class file
	  skel_basename: Basename of skeleton class file
	  stub_suffix: Suffix of stub class file
	  stub_basename: Basename of stub class file
	"""
	def __init__(self, idl_fname = "", impl_suffix = "_impl",
				 skel_suffix = "Skel", stub_suffix = "Stub"):
		self.idl_fname = idl_fname
		self.idl_basename, dummy = idl_fname.split(".")
		self.impl_basename = self.idl_basename + impl_suffix
		self.impl_h = self.impl_basename + ".h"
		self.impl_cpp = self.impl_basename + ".cpp"
		self.impl_suffix = impl_suffix
		self.skel_suffix = skel_suffix
		self.skel_basename = self.idl_basename + skel_suffix
		self.stub_suffix = stub_suffix
		self.stub_basename = self.idl_basename + stub_suffix
		return
	
	def setValue(self, member, value):
		member = member.replace("-", "_")
		if hasattr(self, member):
			setattr(self, member, value)
		return
		


def MakeModuleProfile(opts):
	"""
	MakeModuleProfile

	Create ModuleProfile list from command options
	"""
	prof = ModuleProfile()
	for opt, arg in opts:
		if opt.find("--module-") == 0:
			var = opt.replace("--module-","")
			prof.setValue(var, arg)
	return prof


def MakePortProfile(opts, port_type):
	"""
	MakePortProfile

	Create PortProfile list from command options
	"""
	prof_list = []
	cnt = 0
	for opt, arg in opts:
		if opt.find("--" + port_type) == 0:
			name, type = arg.split(":")
			prof = PortProfile()
			prof.setValue("name", name)
			prof.setValue("type", type)
			prof.setValue("num", cnt)
			prof_list.append(prof)
			cnt += 1
	return prof_list

def MakeServiceProfile(opts):
	"""
	MakeServiceProfile

	Create ServiceProfile list from command options
	"""
	svc_list = []
	impl_suffix = "SVC_impl"
	skel_suffix = "Skel"
	stub_suffix = "Stub"

	for opt, arg in opts:
		if opt.find("--svc-impl-suffix") == 0:
			impl_suffix = arg
		if opt.find("--svc-skel-suffix") == 0:
			skel_suffix = arg
		if opt.find("--svc-stub-suffix") == 0:
			stub_suffix = arg

	for opt, arg in opts:
		if opt.find("--svc-name") == 0:
			ifname, name, type = arg.split(":")
			svc_prof = ServiceProfile(ifname, name, type, impl_suffix)
			svc_list.append(svc_prof)

	return svc_list


def MakeServiceIDL(opts):
	"""
	MakeServiceIDL

	Create ServiceIDL list from command options
	"""
	idl_list = []
	# Default suffixes
	impl_suffix = "SVC_impl"
	skel_suffix = "Skel"
	stub_suffix = "Stub"

	for opt, arg in opts:
		if opt.find("--svc-impl-suffix") == 0:
			impl_suffix = arg
		if opt.find("--svc-skel-suffix") == 0:
			skel_suffix = arg
		if opt.find("--svc-stub-suffix") == 0:
			stub_suffix = arg

	for opt, arg in opts:
		if opt.find("--svc-idl") == 0:
			svc_idl = ServiceIDL(arg, impl_suffix, skel_suffix, stub_suffix)
			idl_list.append(svc_idl)
	return idl_list


def find_opt(opts, value, default):
	for opt, arg in opts:
		if opt.find(value) == 0:
			return arg

	return default


def find_opt_list(opts, value, default):
	list = []
	if len(default) > 0:
		list += default
	for opt, arg in opts:
		if opt.find(value) == 0:
			list.append(arg)
	return list


class Backend:
	def __init__(self, mod_name, mod):
		self.mod = mod
		self.obj = getattr(mod, mod_name)
		self.mod_name = mod_name


class BackendLoader:
	def __init__(self):
		self.backends = {}
		self.opts = []
		self.available()
		return
		

	def available(self):
		path_list = [pyhelper_path, "."]
		for path in path_list:
			for f in os.listdir(path):
				if re.compile("_gen.py$").search(f):
					mod_name = f.replace(".py", "")
					opt_name = f.replace("_gen.py", "")
					mod = __import__(mod_name, globals(), locals(), [])
					try:
						mod.usage()
						be = Backend(mod_name, mod)
						self.backends[opt_name] = be
					except:
						print "Invalid backend: ", f
						pass

		return self.backends


	def check_args(self, args):
		for opt in args:
			if opt.find('-b') == 0:
				backend_name = opt.replace("-b", "")
				if self.backends.has_key(backend_name):
					self.opts.append(backend_name)
				else:
					print "No such backend: ", backend_name
					sys.exit(-1)
			elif opt.find('--backend=') == 0:
				backend_name = opt.replace("--backend=", "")
				if self.backends.has_key(backend_name):
					self.opts.append(backend_name)
				else:
					print "No such backend: ", backend_name
					sys.exit(-1)
		return self.opts


	def get_opt_fmts(self):
		fmts = []
		for be in self.opts:
			fmts += self.backends[be].mod.get_opt_fmt()
		return fmts


	def usage_available(self):
		print "The following backends are available."
		space = 10
		for key in self.backends:
			desc = self.backends[key].mod.description()			
			print "    -b" + key + ("." * (space - len(key))) + desc
		print """
Backend [xxx] specific help can be available by the following options.
    -bxxx --help|-h or --backend=xxx --help|-h
	"""
		return


	def usage(self):
		for be in self.opts:
			print self.backends[be].mod.usage()			
			print ""
		return


	def generate_code(self, data, opts):
		for be in self.opts:
			self.backends[be].obj(data, opts).print_all()
		return
		

def fmtd_args(width, args):
	arg_fmt = [""]
	w = 0
	line = 0
	for a in args:
		w += len(a) + 1
		if w > width:
			w = len(a) + 1
			line += 1
			arg_fmt.append("")
		arg_fmt[line] += a + " "
	return arg_fmt



def main():
	global opt_args_fmt

	backends = BackendLoader()
	backends.check_args(sys.argv[1:])
	opt_args_fmt += backends.get_opt_fmts()

	try:
		opts, args = getopt.getopt(sys.argv[1:], "b:ho:v", opt_args_fmt)
	except getopt.GetoptError:
		print "Error: Invalid option.", getopt.GetoptError
		usage_short()
		backends.usage_available()
		sys.exit(-1)

	if not opts:
		usage_short()
		backends.usage_available()
		sys.exit(-1)

	output = None
	verbose = False
	output_cxx = False
	output_python = False

	for o, a in opts:
		if o == "-v":
			verbose = True
		if o in ("-h"):
			usage_short()
			backends.usage_available()
			backends.usage()
			sys.exit(0)
		if o in ("--help"):
			usage()
			backends.usage_available()
			backends.usage()
			sys.exit(0)
		if o in ("-o", "--output"):
			output = a
			# ...

	prefix, dummy = os.popen("rtm-config --prefix", "r").read().split("\n")
	idl_inc = []
	idl_inc.append(prefix + "/include/rtm/idl")
	idl_inc.append(prefix + "/include/rtm")
	idl_inc.append(".")

	# Create dictionary for ezt
	data = {
		'module':      MakeModuleProfile(opts),
		'inport':      MakePortProfile(opts, "inport"),
		'outport':     MakePortProfile(opts, "outport"),
		'service':     MakeServiceProfile(opts),
		'service_idl': MakeServiceIDL(opts),
		'idl_include': find_opt_list(opts, "--svc-idl-include", idl_inc),
		'impl_suffix': find_opt(opts, "--svc-impl-suffix", "SVC_impl"),
		'skel_suffix': find_opt(opts, "--svc-skel-suffix", "Skel"),
		'stub_suffix': find_opt(opts, "--svc-stub-suffix", "Stub"),
		'fname':       output,
		'args':        sys.argv,
		'fmtd_args':   fmtd_args(70, sys.argv)
		}

	if data['fname'] == None:
		data['fname'] = data['module'].name

	backends.generate_code(data, opts)

	import README_src
	readme_src = README_src.README_src(data)
	readme_src.print_all()
	return
		

if __name__ == "__main__":
	main()
