// -*- IDL -*-
/*!
 * @file RTCPackage.idl
 * @brief RTC package
 * @author Noriaki Ando <n-ando@aist.go.jp>
 *
 * Copyright (C) 2006
 *     Task-intelligence Research Group,
 *     Intelligent Systems Research Institute,
 *     National Institute of
 *         Advanced Industrial Science and Technology (AIST), Japan
 *     All rights reserved.
 *
 * $Id: RTCPackage.idl,v 1.1 2006-04-04 06:01:11 n-ando Exp $
 */

/*
 * $Log: not supported by cvs2svn $
 *
 */


#ifndef    _RTC_PACKAGE_IDL_
#define    _RTC_PACKAGE_IDL_

#include "SDOPackage.idl"

/** CORBA specific model for RTCs */

#pragma prefix "org.omg"

module RTCPackage {

  interface RTC;
  interface Service;
  interface Port;
  typedef sequence<RTC> RTCList;

  /*------------------------------------------------------------
   * Exceptions
   *------------------------------------------------------------*/
  /*!
   * @brief Illegal transition exception
   */
  exception IllegalTransition {};
  exception NotFound { string name;};


  // DataType


  /*!
   * @brief Time value structure
   * A structure store time value.
   */
  struct Time
  {
	unsigned long sec;    // sec
	unsigned long nsec;   // nano sec
  };
  
  /*!
   * @brief Return value of standard RTComponent operation
   *
   * If operation have no specific return value, operation will return RtmRes 
   * type return value. RtmRes have the following pre-defined values:
   * RTC_OK , RTC_ERR , RTC_WARNING , RTC_FATAL_ERR.
   */
  enum RtcRes
  {
	/*!
	 * @brief The operation has returned normally
	 */
	RTC_OK,
	
	/*!
	 * @brief The operation has returned with fatal error
	 */
	RTC_WARNING,
	
	/*!
	 * @brief The operation has returned with error
	 */
	RTC_ERR,
	
	/*!
	 * @brief The operation has returned with fatal error
	 */
	RTC_FATAL_ERR
  };


  /*============================================================
   * Fundamental definition for InPort and OutPort
   *
   * An RTC has 0 or more data stream input port as InPorts
   * and 0 ore more data stream output port as Outport.
   *
   * InPort and OutPort are associated with Subscription data
   * defined as struct, which has subscription type, InPort reference,
   * OutPort reference, subscription id and some properties.
   *
   *============================================================*/

  /*!
   * @brief SubscriptionType definition
   * Subscription type to OutPort.
   */
  enum SubscriptionType
  {
	/*!
	 * @brief PULL: PULL type subscription.
	 * InPort pull data from OutPort, OutPort never push its data.
	 * OutPort gives the last value to the InPort.
	 */
	PULL,
	
	/*!
	 * @brief ONCE: Subscribe Once.
	 * Get only one data asynchronously present, this is to ensure
	 * that the client will not block while the servant is acquiring
	 * the data (may be we need one more option to specify if we want
	 * the data now or the next new data) 
	 */
	ONCE,
	
	/*!
	 * @brief NEW: Get data if updated
	 * Get data every time a new data is available in outport
	 */
	NEW,

	/*!
	 * @brief Get data periodic
	 * Get data at regular pace
	 */
	PERIODIC,

	/*!
	 * @brief Get data if triggered
	 * Get data every time a condition is reached (like "is > 2.0",
	 * we need to define a condition definition language but it's
	 * not yet urgent)
	 */
	TRIGGERED,

	/*!
	 * @brief Get data periodic if updated
	 * Get data at regular pace only if a new data is available
	 * in the outport : especially useful for analog data :
	 * client leads synchro
	 */
	PERIODIC_NEW,

	/*!
	 * @brief Get data if updated and periodic
	 * Get data every time a new data is available in outport
	 * but not faster than a given pace : server leads synchro
	 */
	NEW_PERIODIC,

	/*!
	 * @brief Get data periodic if triggerd
	 * Same as PERIODIC_NEW but the "new" condition is
	 * replaced by the "trigger" condition
	 */
	PERIODIC_TRIGGERRED,

	/*!
	 * @brief Get data if triggered and periodic
	 * Same as TRIGGERED_PERIODIC but the "new" condition
	 * is replaced by the "trigger" condition
	 */
	TRIGGERED_PERIODIC,
	USER_DEFINED
  };


  /*!
   * @brief SubscriberProfile
   * Structure definition of subscriber profile.
   */
  struct SubscriptionProfile
  {
	/*!
	 * @brief Subscription ID
	 * Unique ID for subscription. Usually UUID is used.
	 */
	SDOPackage::UniqueIdentifier id;

	/*!
	 * @brief InPort which is associated with this Subscription
	 */
	Port inport_ref;

	/*!
	 * @brief OutPort which is associated with this Subscription
	 */
	Port outport_ref;
	
	/*!
	 * @brief Subscription
	 * Structure definition of subscriber profile.
	 * Set one of the following subscription type.
	 * PULL, ONCE, PERIODIC, NEW, TRIGGERED, PERIODIC_NEW
	 * NEW_PERIODIC, PERIODIC_TRIGGERED, TRIGGERRED_PERIODIC
	 */
	SubscriptionType subscription_type;

	/*!
	 * @brief Subscriber properties
	 */
	SDOPackage::NVList properties;
  };


  /*!
   * @brief SubscriberProfile list
   */
  typedef sequence<SubscriptionProfile> SubscriptionProfileList;


  /*!
   * @brief A structure of Port profile
   */
  struct PortProfile
  {
	/*!
	 * @brief Name of the Port
	 */
	string name;

	/*!
	 * @brief A reference of InPort
	 */
	Port port_ref;

	/*!
	 * @brief DataType of Port
	 * CORBA TypeCode of the data type is stored.
	 */
	TypeCode port_type;

	/*!
	 * @brief Subscription profile list
	 */
	SubscriptionProfileList subscriptions;

	/*!
	 * @brief Property list
	 */
	SDOPackage::NVList properties;

	/*!
	 * @brief Parent component of the InPort
	 */
	RTC parent;
  };

  typedef sequence<PortProfile> PortProfileList;

  /*============================================================
   * Definition of RTC Port interface
   *============================================================*/
  interface Port
  {
	PortProfile get_port_profile()
	  raises (SDOPackage::NotAvailable, SDOPackage::InternalError);
	SubscriptionProfileList get_subscription_profiles()
	  raises (SDOPackage::NotAvailable, SDOPackage::InternalError);
	SubscriptionProfile get_subscription_profile(in string id)
	  raises (NotFound, SDOPackage::NotAvailable, SDOPackage::InternalError);
	RtcRes subscribe(in SubscriptionProfile profile)
	  raises (SDOPackage::InvalidParameter, SDOPackage::NotAvailable,
			  SDOPackage::InternalError);
	RtcRes unsubscribe(in string id)
	  raises (NotFound, SDOPackage::NotAvailable, SDOPackage::InternalError);
  };

  typedef sequence<Port> PortList;


  /*============================================================
   * Fundamental definition for RTC Service and Consumer
   *
   * An RTC has 0 or more service named RTC Service
   * and 0 ore more service consumer as RTCS Consumer.
   *
   * Service and Consumer are associated with Connection profile
   * defined as struct, which has connection id, properties,
   * Service reference, Consumer reference.
   *
   *============================================================*/

  /*!
   * @brief ConnectionProfile
   * Structure of connection profile.
   */
  struct ConnectionProfile
  {
	/*!
	 * @brief Connection ID
	 * Unique ID for subscription. Usually UUID is used.
	 */
	SDOPackage::UniqueIdentifier connection_id;

	/*!
	 * @brief Service reference which is associated with the connection.
	 */
	Service service_ref;

	/*!
	 * @brief Service reference which is associated with the connection.
	 */
	Service consumer_ref;

	/*!
	 * @brief Subscriber properties
	 */
	SDOPackage::NVList properties;
  };

  typedef sequence<ConnectionProfile> ConnectionProfileList;


  /*!
   * @brief ServiceProfile
   * Profile structure of RTC ServiceProfile
   */
  struct ServiceProfile
  {
	/*!
	 * @brief Name of RTC Service/Consumer
	 */
	string name;

	/*!
	 * @brief The interface type of RTC Service/Consumer
	 */
	string interface_type;

	/*!
	 * @brief Property list
	 */
	SDOPackage::NVList properties;

	/*!
	 * @brief The object reference of of RTC Service/Consumer
	 */
	Service service_ref;

	/*!
	 * @brief ConnectionProfile
	 */
	ConnectionProfileList connection_profiles;

	/*!
	 * @brief The object reference of the parent component
	 */
	RTC parent;
  };

  typedef sequence<ServiceProfile> ServiceProfileList;


  /*============================================================
   * Definition of RTC Service interface
   *============================================================*/
  interface Service
	: SDOPackage::SDOService
  {
	ServiceProfile get_service_profile()
	  raises (SDOPackage::NotAvailable, SDOPackage::InternalError);
	ConnectionProfileList get_connection_profiles()
	  raises (SDOPackage::NotAvailable, SDOPackage::InternalError);
	ConnectionProfile get_connection_profile(in string id)
	  raises (NotFound, SDOPackage::NotAvailable, SDOPackage::InternalError);
	RtcRes connect(in ConnectionProfile profile)
	  raises (SDOPackage::InvalidParameter, SDOPackage::NotAvailable,
			  SDOPackage::InternalError);
	RtcRes disconnect(in string id)
	  raises (NotFound, SDOPackage::NotAvailable, SDOPackage::InternalError);
  };

  typedef sequence<Service> ServiceList;



  /*============================================================
   * Fundamental definition of RTC
   *============================================================*/
  struct ComponentProfile
  {
	SDOPackage::UniqueIdentifier instance_id;
	string implementation_id;
	//	ActivityType activity_type;
	//	ComponentType component_type;
	string description;
	string version;
	string maker;
	string category;

	SDOPackage::NVList properties;

	PortProfileList inport_profile_list;
	PortProfileList outport_profile_list;
	ServiceProfileList service_profile_list;
	ServiceProfileList consumer_profile_list;
	RTC parent;
	//	sequence<short,100> children;
  };

  typedef sequence<ComponentProfile> ComponentProfileList;



  /*============================================================
   * Fundamental definition of RTC interface
   *============================================================*/
  interface RTC
	: SDOPackage::SDO
  {
	enum ComponentState
	{
	  RTC_BORN,
	  RTC_INITIALIZING,
	  RTC_READY,
	  RTC_STARTING,
	  RTC_ACTIVE,
	  RTC_STOPPING,
	  RTC_ABORTING,
	  RTC_ERROR,
	  RTC_FATAL_ERROR,
	  RTC_EXITING
	};
	ComponentProfile get_component_profile();
	ComponentState get_component_state();
  };	



  /*============================================================
   * Definition of RTC Activity interface
   *============================================================*/
  interface Activity
	: SDOPackage::SDOService
  {
	/*!
	 * @brief Activate the components' activity
	 * This operation changes the component state from READY to ACTIVE. 
	 * The state should be READY state, when this operation is called.
	 * In other state, IllegalTransition exception will be raised.
	 * @return Result of this operation.
	 */
	RtcRes rtc_start()
	  raises (IllegalTransition, SDOPackage::InternalError);


	/*!
	 * @brief Stop the component's activity
	 * This operation changes the component state from ACTIVE to READY. 
	 * The state should be ACTIVE state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_stop()
	  raises (IllegalTransition, SDOPackage::InternalError);

	/*!
	 * @brief Reset the component's activity
	 * This operation changes the component state to INITIALIZING.
	 * The state should be READY or ERROR state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_reset()
	  raises (IllegalTransition, SDOPackage::InternalError);

	/*!
	 * @brief Exit the component's activity
	 * This operation changes the component state to EXITING.
	 * The state should be READY or ERROR state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_exit()
	  raises (IllegalTransition, SDOPackage::InternalError);

	/*!
	 * @brief Kill the component's activity
	 * This operation changes the component state to EXITING.
	 * The state should be READY or ERROR state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_kill()
	  raises (IllegalTransition, SDOPackage::InternalError);

	/*!
	 * @brief Suspend the execution entity of the component's activity
	 * This operation suspends the execution entity of the activity.
	 * The state should be READY or ERROR state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_suspend()
	  raises (IllegalTransition, SDOPackage::InternalError);

	/*!
	 * @brief Restart the execution entity of the component's activity
	 * This operation restarts the execution entity of the activity.
	 * The state should be READY or ERROR state, when this operation is called.
	 * In other state, Illegal Transition exception will be raised.
	 */
	RtcRes rtc_restart()
	  raises (IllegalTransition, SDOPackage::InternalError);
  };



};  // end of module RTCPackage


#endif //_RTC_PACKAGE_IDL_
